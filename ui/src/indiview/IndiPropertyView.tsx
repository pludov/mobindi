/**
 * Created by ludovic on 21/07/17.
 */
import React, { Component, PureComponent} from 'react';
import CancellationToken from 'cancellationtoken';
import * as Store from "../Store";
import * as IndiUtils from '../IndiUtils';
import "./IndiManagerView.css";
import { createSelector } from 'reselect';
import { IndiVector, IndiProperty } from '@bo/BackOfficeStatus';
import TextEdit from '../TextEdit';


type InputProps = {
    dev: string;
    vec: string;
    prop:string;
    showVecLabel: boolean;
    compact?: boolean;
    busy?: boolean;
    forcedValue: undefined|string;
    onChange: (prop:string, truc: boolean, value:string)=>(void);
}

type MappedProps = {
    valid: boolean;
    vecLabel: IndiVector["$label"];
    vecType: IndiVector["$type"];
    vecRule: IndiVector["$rule"];
    vecPerm: IndiVector["$perm"];
    propLabel : IndiProperty["$label"];
    value: IndiProperty["$_"];
    format: IndiProperty["$format"];
}

type Props = InputProps & MappedProps;

const sexaFormatRe = /^%([0-9]*).([0-9]*)m$/;
const floatFormatRe = /^%([0-9]*)\.([0-9]*)f$/;

/** Render a property as key: value (readonly) */
class IndiPropertyView extends PureComponent<Props> {
    renderValue(value:string) {
        return this.renderValueWithFormat(value, this.props.format);
    }

    renderValueWithFormat(value:string, format?: string):string
    {
        if (format !== undefined)
        {
            var fixedFloatFormat = format.match(floatFormatRe);
            if (fixedFloatFormat) {
                var floatValue = parseFloat(value);
                if (isNaN(floatValue)) return value;

                if (fixedFloatFormat[2].length > 0) {
                    return floatValue.toFixed(parseInt(fixedFloatFormat[2]));
                } else {
                    return "" + floatValue;
                }
            }
            
            var sexaFormat =  format.match(sexaFormatRe);
            if (sexaFormat) {
                var level = parseInt(sexaFormat[2]);
                var mult, pattern;
                if (level < 3) {
                    mult = 1;
                    pattern = "#";
                } else if (level <= 3) {
                    mult = 60;
                    pattern = "#:6#"
                } else if (level <= 5) {
                    mult = 600;
                    pattern = "#:6#.#"
                } else if (level <= 6) {
                    mult = 3600;
                    pattern = "#:6#:6#"
                } else if (level <= 8) {
                    mult = 36000;
                    pattern = "#:6#:6#.#"
                } else {
                    mult = 360000;
                    pattern = "#:6#:6#.##"
                }

                const fvalue = parseFloat(value);
                if (isNaN(fvalue)) {
                    return "ERROR";
                }

                if (Math.abs(Math.round(fvalue * mult)) >= 1e+20) {
                    return value;
                }

                var str = "";
                var ivalue = Math.round(fvalue * mult);

                if (ivalue < 0) {
                    str += '-';
                    ivalue = -ivalue;
                }

                var xlatPattern = "";
                for(var i = pattern.length - 1; i >= 0; --i) {
                    var c = pattern[i];
                    if (c == '#' || c == '6') {
                        var div = (c == '#' ? 10 : 6);
                        var v = Math.floor(ivalue % div);
                        ivalue = Math.floor(ivalue / div);
                        c = v.toFixed(0);
                    } else {
                        c = pattern[i];
                    }
                    xlatPattern = c + xlatPattern;
                }
                while (ivalue >= 0.5) {
                    var v = Math.floor(ivalue % 10);
                    ivalue = Math.floor(ivalue / 10);

                    xlatPattern = v.toFixed(0) + xlatPattern;
                }
                str += xlatPattern;
                return str;
            }
            return value;
        } else {
            return value;
        }
    }

    parseValue(value:string):string
    {
        var format = this.props.format;
        if (format !== undefined) {
            if (format.match(floatFormatRe)) {
                return "" + parseFloat(value);
            }
            if (format.match(sexaFormatRe)) {
                // Parse a float
                var sep;
                if ((sep = value.indexOf(':')) != -1) {
                    var head = value.substr(0, sep).trim();
                    head = head.replace(' ', '');

                    var floatValue = parseFloat(head);
                    if (isNaN(floatValue)) {
                        return "" + parseFloat(value);
                    }
                    var left = value.substr(sep + 1).trim();
                    var divider = 60;
                    if (head[0] == '-') {
                        divider = -60;
                    }
                    while(left.length) {
                        var toParse;
                        sep = left.indexOf(':');
                        if (sep != -1) {
                            toParse = left.substr(0, sep).trim();
                            left = left.substr(sep + 1).trim();
                        } else {
                            toParse = left;
                            left = '';
                        }
                        var v = parseFloat(toParse) / divider;
                        if (isNaN(v)) {
                            return "" + parseFloat(value);
                        }
                        floatValue += v;
                        divider *= 60;
                    }
                    return "" + floatValue;
                } else {
                    return "" + parseFloat(value);
                }
            }
        }

        return value;
    }
    // props: app, dev, vec, prop, showVecLabel,
    // props: forcedValue
    // onChange(newValue)
    render() {
        if (!this.props.valid) {
            return null;
        }
        let label = this.props.propLabel;
        if (this.props.vecLabel != undefined && label != this.props.vecLabel) {
            label = this.props.vecLabel + ": " + label;
        }

        let className= this.props.compact ? "IndiPropertyCompact": "IndiProperty";
        const busyClassName = this.props.busy ? " BusyInfinite " : ""
/*        var test = [ -400, -0.0001, 0.00001, 0.99999999999, 1.000000001, 20.9914239, 45212145421241.9914239, 1e19 ];
        var formats = [ "%1.0m", "%1.3m", "%1.5m", "%1.6m", "%1.8m", "%1.9m"];
        for(var i  = 0; i < test.length; ++i) {
            var v = test[i];
            logger.debug("with " + v);
            for(var j = 0; j < formats.length; ++j) {
                var format = formats[j];
                logger.debug('  ' + format + '   =>  ' + this.renderValueWithFormat(v, format));
            }
        }
*/
        if (this.props.vecType == 'Switch' && this.props.vecPerm != 'ro') {
            if (this.props.vecRule == 'AtMostOne') {
                return <>
                    <input
                        type="button"
                        className={busyClassName + "IndiSwitchButton IndiSwitchButton" + this.props.value}
                        value={label}
                        onClick={(e) => {
                            this.props.onChange(
                                this.props.prop,
                                true,
                                this.props.value == 'On' ? 'Off' : 'On')
                            }}
                            />
                    {this.props.children}
                </>

            } else {
                return <div className={className}>
                    <input
                        className={busyClassName}
                        type="checkbox"
                        checked={this.props.value == 'On'}
                        onChange={(e) => {
                            this.props.onChange(
                                this.props.prop,
                                true, // Could be false as well... Depends on driver
                                e.target.checked ? 'On' : 'Off');
                        }}
                    ></input>
                    {label}{this.props.children}</div>
            }
        } else if (this.props.vecPerm != 'ro') {
            return <div className={className}>
                        {!this.props.compact ? label + ":" : "" }
                        <TextEdit
                            value={this.renderValue(this.props.value)}
                            busy={this.props.busy}
                            onChange={(e)=> {this.props.onChange(this.props.prop, false, this.parseValue(e))}}/>
                        {this.props.children}
                    </div>;
        } else {
            return <div className={className}>{label}: {this.renderValue(this.props.value)}{this.props.children}</div>
        }
    }


    static mapStateToProps=(store: Store.Content, ownProps:InputProps)=>{
        const vec = IndiUtils.getVectorDesc(store, ownProps.dev, ownProps.vec);

        const prop = vec === undefined
            ? undefined
            : Object.prototype.hasOwnProperty.call(vec.childs, ownProps.prop)
                ? vec.childs[ownProps.prop]
                : undefined;

        if (vec === undefined || prop === undefined) {
            return {
                valid: false,
                vecLabel: "",
                vecType: "Switch",
                vecPerm: "",
                propLabel: "",
                vecRule: "",
                value: "",
                format: "",
            } as MappedProps
        } else {
            return {
                valid: true,
                vecLabel: ownProps.showVecLabel ? vec.$label: undefined,
                vecType: vec.$type,
                vecRule: vec.$rule,
                vecPerm: vec.$perm,
                propLabel : ownProps.showVecLabel ? vec.$label : prop.$label,
                value: ownProps.forcedValue != undefined ? ownProps.forcedValue: prop.$_,
                format: prop.$format
            } as MappedProps;
        }
    }
}

export default Store.Connect(IndiPropertyView);
